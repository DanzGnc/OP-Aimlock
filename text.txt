--[[
  GNC HUB - Aimlock + ESP UI (Ultra Modern Complex) - V2 Enhanced
  by OpenAI GPT-4.1 & Upgraded by Assistant
  2025 Complex UI: Minimize, Theme Switch, Resizable, Animation, Smooth UX, Advanced Features
]]--

local Players        = game:GetService("Players")
local RunService     = game:GetService("RunService")
local VirtualUser    = game:GetService("VirtualUser")
local UserInputService = game:GetService("UserInputService")
local TweenService   = game:GetService("TweenService")
local HttpService    = game:GetService("HttpService") -- For config saving/loading (if using JSON)
local CoreGui        = game:GetService("CoreGui")

local LocalPlayer    = Players.LocalPlayer
local Camera         = workspace.CurrentCamera
local Mouse          = LocalPlayer:GetMouse()

-- SETTINGS (Centralized)
local Settings = {
    -- Aimlock
    AimlockEnabled = true,
    AimlockMode    = "Enemy", -- Normal, Team, Enemy
    AimlockPart    = "Head",  -- Head, Torso, HumanoidRootPart
    AimlockKey     = Enum.KeyCode.MouseButton2, -- Hold to aim
    AimlockFOV     = 150,     -- FOV radius in pixels
    AimlockSmoothness = 5,    -- Higher = slower/smoother (1 = no smooth)
    AimlockPrediction = false, -- Basic velocity prediction
    AimlockVisibilityCheck = true,

    -- ESP
    ESPEnabled     = true, -- Master ESP toggle
    ESPBox         = true,
    ESPLine        = false,
    ESPName        = true,
    ESPDistance    = true,
    ESPHealthBar   = true,
    ESPSkeleton    = false,
    ESPShowTeam    = true,
    ESPShowEnemies = true,
    ESPVisibleColor = Color3.fromRGB(255, 60, 60), -- For visible enemies
    ESPOccludedColor = Color3.fromRGB(255, 150, 150), -- For occluded enemies
    ESPTeamColor   = Color3.fromRGB(60, 255, 60),
    ESPMaxDistance = 500, -- Max distance for ESP to render

    -- Misc
    ShowFOVCircle  = true,
    AntiKick       = true, -- The existing anti-kick
    ConfigName     = "DefaultGNCConfig",
}

local lockedTarget = nil
local espObjects   = {}
local aimlockActive = false -- For AimKey logic
local currentConfig = Settings.ConfigName

-- Theme table
local Themes = {
    Dark = {
        Frame = Color3.fromRGB(18,22,30), Header = Color3.fromRGB(25,30,48),
        Text = Color3.fromRGB(220,220,220), Accent = Color3.fromRGB(0,255,180),
        Accent2 = Color3.fromRGB(0,255,220), Subtle = Color3.fromRGB(150,255,200),
        Bg2 = Color3.fromRGB(22,24,30), SwitchOff = Color3.fromRGB(35,55,70),
        SwitchCircleOff = Color3.fromRGB(100,100,100), SwitchIconOff = Color3.fromRGB(70,70,70),
        SliderTrack = Color3.fromRGB(40,45,60), SliderProgress = Color3.fromRGB(0,255,180),
        InputBorder = Color3.fromRGB(50,60,80), InputBackground = Color3.fromRGB(30,35,50),
    },
    Light = {
        Frame = Color3.fromRGB(230,240,250), Header = Color3.fromRGB(210,225,240),
        Text = Color3.fromRGB(36,45,55), Accent = Color3.fromRGB(0,200,120),
        Accent2 = Color3.fromRGB(0,200,180), Subtle = Color3.fromRGB(0,180,120),
        Bg2 = Color3.fromRGB(245,255,255), SwitchOff = Color3.fromRGB(200,210,220),
        SwitchCircleOff = Color3.fromRGB(180,180,180), SwitchIconOff = Color3.fromRGB(150,150,150),
        SliderTrack = Color3.fromRGB(190,200,210), SliderProgress = Color3.fromRGB(0,200,120),
        InputBorder = Color3.fromRGB(180,190,200), InputBackground = Color3.fromRGB(220,230,240),
    }
}
local Theme = Themes.Dark -- Default theme

-- AFK & Kick Prevention
if Settings.AntiKick then
    LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
    if hookmetamethod then
        pcall(function()
            local mt = getrawmetatable(game)
            local oldIsReadOnly = isreadonly(mt)
            setreadonly(mt, false)
            local old = mt.__namecall
            mt.__namecall = newcclosure(function(self, ...)
                if getnamecallmethod():lower() == "kick" then
                    -- warn("GNC Hub: Kick attempt prevented for "..LocalPlayer.Name)
                    return wait(9e9) -- Effectively yield indefinitely
                end
                return old(self, ...)
            end)
            setreadonly(mt, oldIsReadOnly)
        end)
    end
end

-- Visibility Check function
local function isVisible(targetPart)
    if not targetPart then return false end
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit * (origin - targetPart.Position).Magnitude
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
    params.IgnoreWater = true
    local result = workspace:Raycast(origin, direction, params)
    return result and result.Instance:IsDescendantOf(targetPart.Parent)
end

-- Targeting Logic
local function isValidTarget(player)
    if not player or player == LocalPlayer then return false end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or not player.Character:FindFirstChild("Head") then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end

    if Settings.AimlockMode == "Team" and player.TeamColor ~= LocalPlayer.TeamColor then return false end
    if Settings.AimlockMode == "Enemy" and player.TeamColor == LocalPlayer.TeamColor then return false end
    
    local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        local dist = (rootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
        if dist > Settings.ESPMaxDistance then return false end -- Use ESPMaxDistance for general relevance
    end

    return true
end

local function getTargetPart(character)
    local partName = Settings.AimlockPart
    if partName == "Body" then partName = "Torso" end -- Alias
    local target = character:FindFirstChild(partName)
    if not target and partName == "Torso" then target = character:FindFirstChild("UpperTorso") end -- R15
    if not target then target = character:FindFirstChild("HumanoidRootPart") end -- Fallback
    return target
end

local function getClosestTargetToCrosshair()
    local closestPlayer, minAngle = nil, math.huge
    local localCharacter = LocalPlayer.Character
    if not localCharacter or not localCharacter:FindFirstChild("HumanoidRootPart") then return nil end

    local cameraDirection = Camera.CFrame.LookVector

    for _, player in ipairs(Players:GetPlayers()) do
        if isValidTarget(player) then
            local targetCharacter = player.Character
            local targetPart = getTargetPart(targetCharacter)
            if targetPart then
                local targetPos = targetPart.Position
                local directionToTarget = (targetPos - Camera.CFrame.Position).Unit
                local angle = math.acos(cameraDirection:Dot(directionToTarget))

                -- Screen FOV check
                local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
                if onScreen then
                    local distFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude -- Using Mouse.X, Mouse.Y for crosshair assuming centered
                    if distFromCenter < Settings.AimlockFOV then
                         if Settings.AimlockVisibilityCheck and not isVisible(targetPart) then
                            -- continue -- Skip if visibility check is on and target is not visible
                         else
                            if angle < minAngle then -- Prioritize angle for 3D FOV, then screen distance as tie-breaker or primary if 3D FOV is too wide
                                minAngle = angle
                                closestPlayer = player
                            end
                        end
                    end
                end
            end
        end
    end
    return closestPlayer
end


-- UI CLEANUP
local cg = CoreGui
local existing = cg:FindFirstChild("AimlockESPUI_V2")
if existing then existing:Destroy() end

-- UI START
local gui = Instance.new("ScreenGui")
gui.Name = "AimlockESPUI_V2"
gui.Parent = cg
gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
gui.ResetOnSpawn = false -- Important for scripts not to reset on death

-- === MAIN FRAME ===
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 340, 0, 480) -- Slightly wider for more options
frame.Position = UDim2.new(0.68, 0, 0.13, 0)
frame.BackgroundColor3 = Theme.Frame
frame.BackgroundTransparency = 0.1
frame.BorderSizePixel = 0
frame.Active = true
frame.ZIndex = 20
frame.ClipsDescendants = true -- Important for rounded corners on children
frame.Parent = gui

local uicorner = Instance.new("UICorner", frame)
uicorner.CornerRadius = UDim.new(0, 12)

-- Modern Shadow using UIStroke on a background frame
local shadowFrame = Instance.new("Frame", frame) -- Sits behind the main content frame
shadowFrame.Size = UDim2.new(1, 0, 1, 0)
shadowFrame.Position = UDim2.new(0, 0, 0, 0)
shadowFrame.BackgroundTransparency = 1 -- Make it transparent initially
shadowFrame.ZIndex = 19
local shadowStroke = Instance.new("UIStroke", shadowFrame)
shadowStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
shadowStroke.Color = Color3.fromRGB(0,0,0)
shadowStroke.Thickness = 8 -- Adjust for desired shadow size/blur
shadowStroke.Transparency = 0.75 -- Adjust for shadow intensity
local shadowCorner = Instance.new("UICorner", shadowFrame)
shadowCorner.CornerRadius = uicorner.CornerRadius


-- === HEADER ===
local header = Instance.new("Frame", frame)
header.Size = UDim2.new(1,0, 0, 50)
header.BackgroundColor3 = Theme.Header
header.BackgroundTransparency = 0.3
header.ZIndex = 21

local title = Instance.new("TextLabel", header)
title.Position = UDim2.new(0, 15, 0, 0)
title.Size = UDim2.new(1, -90, 1, 0)
title.Text = "âš¡ GNC HUB v2"
title.Font = Enum.Font.GothamBold
title.TextSize = 22
title.TextColor3 = Theme.Accent
title.BackgroundTransparency = 1
title.TextXAlignment = Enum.TextXAlignment.Left
title.ZIndex = 22

-- === MINIMIZE BUTTON ===
local minimizeButton = Instance.new("TextButton", header)
minimizeButton.Size = UDim2.new(0, 30, 0, 30)
minimizeButton.Position = UDim2.new(1, -38, 0, 10)
minimizeButton.Text = "â–¼"
minimizeButton.Font = Enum.Font.GothamBlack
minimizeButton.TextSize = 18
minimizeButton.BackgroundTransparency = 0.7
minimizeButton.TextColor3 = Theme.Text
minimizeButton.BackgroundColor3 = Theme.Bg2
minimizeButton.ZIndex = 23
local minCorner = Instance.new("UICorner", minimizeButton)
minCorner.CornerRadius = UDim.new(0, 8)

-- === THEME SWITCHER ===
local themeSwitcher = Instance.new("TextButton", header)
themeSwitcher.Size = UDim2.new(0, 30, 0, 30)
themeSwitcher.Position = UDim2.new(1, -74, 0, 10)
themeSwitcher.Text = "â˜¼" -- Sun icon for light, moon for dark
themeSwitcher.Font = Enum.Font.GothamBold
themeSwitcher.TextSize = 18
themeSwitcher.BackgroundTransparency = 0.7
themeSwitcher.TextColor3 = Theme.Accent
themeSwitcher.BackgroundColor3 = Theme.Bg2
themeSwitcher.ZIndex = 23
local themeCorner = Instance.new("UICorner", themeSwitcher)
themeCorner.CornerRadius = UDim.new(0, 8)


-- === NOTIFY ===
local notify = Instance.new("TextLabel", frame)
notify.Size = UDim2.new(1, -20, 0, 22)
notify.Position = UDim2.new(0, 10, 0, 55)
notify.BackgroundTransparency = 1
notify.Text = ""
notify.TextColor3 = Theme.Subtle
notify.Font = Enum.Font.GothamSemibold
notify.TextSize = 14
notify.ZIndex = 30
notify.TextXAlignment = Enum.TextXAlignment.Left

local notifyTween
local function showNotify(txt, duration)
    notify.Text = txt
    notify.TextTransparency = 0
    duration = duration or 2

    if notifyTween then notifyTween:Cancel() end

    notifyTween = TweenService:Create(notify, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {TextTransparency = 0})
    notifyTween:Play()

    delay(duration, function()
        if notify.Text == txt then -- Only fade if it's the same message
            notifyTween = TweenService:Create(notify, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {TextTransparency = 1})
            notifyTween:Play()
            notifyTween.Completed:Connect(function()
                if notify.TextTransparency == 1 then notify.Text = "" end -- Clear text after fade if still transparent
            end)
        end
    end)
end


-- === SCROLLABLE CONTENT ===
local scrollFrame = Instance.new("ScrollingFrame", frame)
scrollFrame.Size = UDim2.new(1, -10, 1, -135) -- Adjusted for header and config bar
scrollFrame.Position = UDim2.new(0, 5, 0, 80)
scrollFrame.BackgroundTransparency = 1
scrollFrame.BorderSizePixel = 0
scrollFrame.ScrollBarThickness = 6
scrollFrame.ScrollBarImageColor3 = Theme.Accent
scrollFrame.CanvasSize = UDim2.new(0,0,0,0) -- Will be auto by layout
scrollFrame.ZIndex = 23
scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
scrollFrame.ClipsDescendants = false -- Allow elements to pop out slightly if needed (tooltips etc.)

local layout = Instance.new("UIListLayout", scrollFrame)
layout.Padding = UDim.new(0, 8)
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.HorizontalAlignment = Enum.HorizontalAlignment.Center

-- === DRAGGABLE FRAME ===
local dragging, dragInput, dragStart, startPos
local function beginDrag(input)
    dragging = true
    dragStart = input.Position
    startPos = frame.Position
    local conn
    conn = input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
            if conn then conn:Disconnect() end
        end
    end)
end
local function updateDrag(input)
    if dragging then
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end
header.InputBegan:Connect(function(input) -- Only drag by header
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        beginDrag(input)
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
        if dragging then updateDrag(input) end
    end
end)

-- === RESIZABLE FRAME ===
local resizeHandle = Instance.new("ImageLabel", frame)
resizeHandle.Size = UDim2.new(0,20,0,20)
resizeHandle.Position = UDim2.new(1,-20,1,-20)
resizeHandle.Image = "rbxassetid://3568440331" -- Resize icon (diagonal arrows)
resizeHandle.ImageColor3 = Theme.Accent
resizeHandle.BackgroundTransparency = 1
resizeHandle.ZIndex = 50
resizeHandle.Active = true

local resizing = false
local resizeStartMouse, frameStartSize
resizeHandle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        resizing = true
        resizeStartMouse = input.Position
        frameStartSize = frame.AbsoluteSize
        local conn
        conn = input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                resizing = false
                if conn then conn:Disconnect() end
            end
        end)
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if resizing and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - resizeStartMouse
        local newW = math.clamp(frameStartSize.X + delta.X, 300, 800)
        local newH = math.clamp(frameStartSize.Y + delta.Y, 280, 900)
        frame.Size = UDim2.new(0, newW, 0, newH)
    end
end)

-- Utility: Create Section Header
local function createSectionHeader(text, parent)
    local sectionLabel = Instance.new("TextLabel", parent)
    sectionLabel.Size = UDim2.new(1, -10, 0, 25)
    sectionLabel.Text = text
    sectionLabel.Font = Enum.Font.GothamBold
    sectionLabel.TextSize = 18
    sectionLabel.TextColor3 = Theme.Accent2
    sectionLabel.BackgroundTransparency = 1
    sectionLabel.TextXAlignment = Enum.TextXAlignment.Left
    sectionLabel.LayoutOrder = 0 -- Should be set before items in section
    local bottomBorder = Instance.new("Frame", sectionLabel)
    bottomBorder.Size = UDim2.new(1, 0, 0, 2)
    bottomBorder.Position = UDim2.new(0,0,1,-2)
    bottomBorder.BackgroundColor3 = Theme.Accent2
    bottomBorder.BackgroundTransparency = 0.5
    bottomBorder.BorderSizePixel = 0
    return sectionLabel
end

-- === UI Element Creators ===

-- TOGGLE SWITCH
local function createSwitch(labelText, settingKey, descriptionText, changeCallback)
    local container = Instance.new("Frame")
    container.Name = settingKey .. "Container"
    container.Size = UDim2.new(1, -20, 0, 50) -- Increased height for desc
    container.BackgroundTransparency = 1
    container.Parent = scrollFrame -- temporary parent for sizing

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.7, -50, 0, 25)
    label.Position = UDim2.new(0, 0, 0, 5)
    label.Text = labelText
    label.Font = Enum.Font.GothamSemibold
    label.TextSize = 16
    label.TextColor3 = Theme.Text
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left

    local description = Instance.new("TextLabel", container)
    description.Size = UDim2.new(0.7, -50, 0, 15)
    description.Position = UDim2.new(0, 0, 0, 28)
    description.Text = descriptionText or ""
    description.Font = Enum.Font.Gotham
    description.TextSize = 12
    description.TextColor3 = Theme.Subtle
    description.BackgroundTransparency = 1
    description.TextXAlignment = Enum.TextXAlignment.Left

    local switch = Instance.new("Frame", container)
    switch.Name = "SwitchFrame"
    switch.Size = UDim2.new(0, 44, 0, 20)
    switch.Position = UDim2.new(1, -44, 0.5, -10)
    switch.BackgroundColor3 = Settings[settingKey] and Theme.Accent or Theme.SwitchOff
    switch.BorderSizePixel = 0
    local switchCorner = Instance.new("UICorner", switch)
    switchCorner.CornerRadius = UDim.new(0, 10)

    local circle = Instance.new("Frame", switch)
    circle.Name = "SwitchCircle"
    circle.Size = UDim2.new(0, 16, 0, 16)
    circle.Position = Settings[settingKey] and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
    circle.BackgroundColor3 = Settings[settingKey] and Color3.fromRGB(255,255,255) or Theme.SwitchCircleOff
    circle.BorderSizePixel = 0
    local circCorner = Instance.new("UICorner", circle)
    circCorner.CornerRadius = UDim.new(1,0)

    local btn = Instance.new("TextButton", switch)
    btn.BackgroundTransparency = 1
    btn.Size = UDim2.new(1,0,1,0)
    btn.Text = ""
    btn.ZIndex = 2

    local currentTween
    btn.MouseButton1Click:Connect(function()
        Settings[settingKey] = not Settings[settingKey]
        local targetColor = Settings[settingKey] and Theme.Accent or Theme.SwitchOff
        local targetCircleColor = Settings[settingKey] and Color3.fromRGB(255,255,255) or Theme.SwitchCircleOff
        local targetPos = Settings[settingKey] and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)

        if currentTween then currentTween:Cancel() end
        
        local tweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        currentTween = TweenService:Create(switch, tweenInfo, {BackgroundColor3 = targetColor})
        currentTween:Play()
        currentTween = TweenService:Create(circle, tweenInfo, {BackgroundColor3 = targetCircleColor, Position = targetPos})
        currentTween:Play()

        showNotify(labelText.." "..(Settings[settingKey] and "ON" or "OFF"))
        if changeCallback then changeCallback(Settings[settingKey]) end
    end)
    
    container.Parent = nil -- remove temporary parent
    return container
end

-- MODE PICKER (Dropdown-like)
local function createModePicker(labelText, settingKey, modesArray, descriptionText, changeCallback)
    local container = Instance.new("Frame")
    container.Name = settingKey .. "Container"
    container.Size = UDim2.new(1, -20, 0, 50)
    container.BackgroundTransparency = 1
    container.Parent = scrollFrame 

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.5, 0, 0, 25)
    label.Position = UDim2.new(0, 0, 0, 5)
    label.Text = labelText
    label.Font = Enum.Font.GothamSemibold
    label.TextSize = 16
    label.TextColor3 = Theme.Text
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left

    local description = Instance.new("TextLabel", container)
    description.Size = UDim2.new(0.5, 0, 0, 15)
    description.Position = UDim2.new(0, 0, 0, 28)
    description.Text = descriptionText or ""
    description.Font = Enum.Font.Gotham
    description.TextSize = 12
    description.TextColor3 = Theme.Subtle
    description.BackgroundTransparency = 1
    description.TextXAlignment = Enum.TextXAlignment.Left

    local dropdownButton = Instance.new("TextButton", container)
    dropdownButton.Name = "DropdownButton"
    dropdownButton.Size = UDim2.new(0, 120, 0, 28)
    dropdownButton.Position = UDim2.new(1, -120, 0.5, -14)
    dropdownButton.BackgroundColor3 = Theme.Bg2
    dropdownButton.TextColor3 = Theme.Accent
    dropdownButton.Font = Enum.Font.GothamSemibold
    dropdownButton.TextSize = 14
    dropdownButton.Text = Settings[settingKey]
    local ddCorner = Instance.new("UICorner", dropdownButton)
    ddCorner.CornerRadius = UDim.new(0, 6)
    local ddStroke = Instance.new("UIStroke", dropdownButton)
    ddStroke.Color = Theme.InputBorder
    ddStroke.Thickness = 1

    local dropdownList = Instance.new("Frame", container)
    dropdownList.Name = "DropdownList"
    dropdownList.Size = UDim2.new(0, 120, 0, #modesArray * 28)
    dropdownList.Position = UDim2.new(1, -120, 0.5, 14) -- Position below button
    dropdownList.BackgroundColor3 = Theme.Bg2
    dropdownList.BorderSizePixel = 1
    dropdownList.BorderColor3 = Theme.InputBorder
    dropdownList.Visible = false
    dropdownList.ZIndex = 100 -- Above other elements
    local dlCorner = Instance.new("UICorner", dropdownList)
    dlCorner.CornerRadius = UDim.new(0, 6)
    local dlLayout = Instance.new("UIListLayout", dropdownList)
    dlLayout.SortOrder = Enum.SortOrder.LayoutOrder
    dlLayout.Padding = UDim.new(0,2)


    for i, modeName in ipairs(modesArray) do
        local modeOption = Instance.new("TextButton", dropdownList)
        modeOption.Name = modeName
        modeOption.Size = UDim2.new(1, 0, 0, 24)
        modeOption.BackgroundColor3 = Theme.Bg2
        modeOption.TextColor3 = Theme.Text
        modeOption.Font = Enum.Font.Gotham
        modeOption.TextSize = 13
        modeOption.Text = modeName
        modeOption.ZIndex = 101
        modeOption.LayoutOrder = i

        modeOption.MouseEnter:Connect(function() modeOption.BackgroundColor3 = Theme.Accent2; modeOption.TextColor3 = Theme.Frame end)
        modeOption.MouseLeave:Connect(function() modeOption.BackgroundColor3 = Theme.Bg2; modeOption.TextColor3 = Theme.Text end)
        modeOption.MouseButton1Click:Connect(function()
            Settings[settingKey] = modeName
            dropdownButton.Text = modeName
            dropdownList.Visible = false
            showNotify(labelText .. " set to " .. modeName)
            if changeCallback then changeCallback(modeName) end
        end)
    end
    
    dropdownButton.MouseButton1Click:Connect(function()
        dropdownList.Visible = not dropdownList.Visible
        if dropdownList.Visible then
             dropdownList.ZIndex = gui.Enabled and 200 or 0 -- Ensure it's on top
        end
    end)
    
    -- Hide dropdown if clicked outside
    local function clickOutside(input)
        if dropdownList.Visible and 
           not dropdownButton:IsAncestorOf(input.UserInputObject) and 
           not dropdownList:IsAncestorOf(input.UserInputObject) then
            dropdownList.Visible = false
        end
    end
    if UserInputService.InputBegan:Connect(clickOutside) then end -- Basic outside click

    container.Parent = nil
    return container
end

-- SLIDER
local function createSlider(labelText, settingKey, minVal, maxVal, step, descriptionText, changeCallback)
    local container = Instance.new("Frame")
    container.Name = settingKey .. "Container"
    container.Size = UDim2.new(1, -20, 0, 60) -- Taller for slider
    container.BackgroundTransparency = 1
    container.Parent = scrollFrame

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.6, -10, 0, 20)
    label.Position = UDim2.new(0, 0, 0, 5)
    label.Text = labelText
    label.Font = Enum.Font.GothamSemibold
    label.TextSize = 16
    label.TextColor3 = Theme.Text
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left

    local valueLabel = Instance.new("TextLabel", container)
    valueLabel.Name = "ValueLabel"
    valueLabel.Size = UDim2.new(0.3, 0, 0, 20)
    valueLabel.Position = UDim2.new(1, -valueLabel.AbsoluteSize.X - 5 , 0, 5)
    valueLabel.Font = Enum.Font.GothamBold
    valueLabel.TextSize = 15
    valueLabel.TextColor3 = Theme.Accent
    valueLabel.BackgroundTransparency = 1
    valueLabel.TextXAlignment = Enum.TextXAlignment.Right
    valueLabel.Text = tostring(Settings[settingKey])
    
    local description = Instance.new("TextLabel", container)
    description.Size = UDim2.new(1,0,0,15)
    description.Position = UDim2.new(0,0,0,43)
    description.Text = descriptionText or ""
    description.Font = Enum.Font.Gotham
    description.TextSize = 12
    description.TextColor3 = Theme.Subtle
    description.BackgroundTransparency = 1
    description.TextXAlignment = Enum.TextXAlignment.Left


    local track = Instance.new("Frame", container)
    track.Name = "SliderTrack"
    track.Size = UDim2.new(1, 0, 0, 8)
    track.Position = UDim2.new(0, 0, 0, 28)
    track.BackgroundColor3 = Theme.SliderTrack
    track.BorderSizePixel = 0
    local trackCorner = Instance.new("UICorner", track)
    trackCorner.CornerRadius = UDim.new(0, 4)

    local progress = Instance.new("Frame", track)
    progress.Name = "SliderProgress"
    progress.Size = UDim2.new((Settings[settingKey] - minVal) / (maxVal - minVal), 0, 1, 0)
    progress.BackgroundColor3 = Theme.SliderProgress
    progress.BorderSizePixel = 0
    local progressCorner = Instance.new("UICorner", progress)
    progressCorner.CornerRadius = UDim.new(0, 4)

    local thumb = Instance.new("Frame", track)
    thumb.Name = "SliderThumb"
    thumb.Size = UDim2.new(0, 14, 0, 14) -- Circle thumb
    thumb.AnchorPoint = Vector2.new(0.5, 0.5)
    thumb.Position = UDim2.new(progress.Size.X.Scale, 0, 0.5, 0)
    thumb.BackgroundColor3 = Theme.Accent2
    thumb.BorderSizePixel = 0
    local thumbCorner = Instance.new("UICorner", thumb)
    thumbCorner.CornerRadius = UDim.new(1, 0) -- Makes it a circle

    local isDraggingSlider = false
    local function updateSlider(inputPos)
        local relativeX = math.clamp((inputPos.X - track.AbsolutePosition.X) / track.AbsoluteSize.X, 0, 1)
        local value = minVal + (maxVal - minVal) * relativeX
        value = math.floor(value / step + 0.5) * step -- Snap to step
        Settings[settingKey] = value
        valueLabel.Text = string.format("%.1f", value) -- Show one decimal if step allows
        progress.Size = UDim2.new(relativeX, 0, 1, 0)
        thumb.Position = UDim2.new(relativeX, 0, 0.5, 0)
        if changeCallback then changeCallback(value) end
    end

    track.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDraggingSlider = true
            updateSlider(input.Position)
            local conn
            conn = UserInputService.InputEnded:Connect(function(endInput)
                if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    isDraggingSlider = false
                     if conn then conn:Disconnect() end
                    showNotify(labelText .. " set to " .. Settings[settingKey])
                end
            end)
        end
    end)
    track.InputChanged:Connect(function(input)
        if isDraggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then
            updateSlider(input.Position)
        end
    end)
    
    -- Ensure thumb is also clickable to start drag
    thumb.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            isDraggingSlider = true
            local conn
            conn = UserInputService.InputEnded:Connect(function(endInput)
                 if endInput.UserInputType == Enum.UserInputType.MouseButton1 then
                    isDraggingSlider = false
                    if conn then conn:Disconnect() end
                    showNotify(labelText .. " set to " .. Settings[settingKey])
                end
            end)
        end
    end)


    container.Parent = nil
    return container
end

-- KEYBIND INPUT
local function createKeybindInput(labelText, settingKey, descriptionText)
    local container = Instance.new("Frame")
    container.Name = settingKey .. "Container"
    container.Size = UDim2.new(1, -20, 0, 50)
    container.BackgroundTransparency = 1
    container.Parent = scrollFrame

    local label = Instance.new("TextLabel", container)
    label.Size = UDim2.new(0.5, 0, 0, 25)
    label.Position = UDim2.new(0, 0, 0, 5)
    label.Text = labelText
    label.Font = Enum.Font.GothamSemibold
    label.TextSize = 16
    label.TextColor3 = Theme.Text
    label.BackgroundTransparency = 1
    label.TextXAlignment = Enum.TextXAlignment.Left

    local description = Instance.new("TextLabel", container)
    description.Size = UDim2.new(0.5, 0, 0, 15)
    description.Position = UDim2.new(0, 0, 0, 28)
    description.Text = descriptionText or ""
    description.Font = Enum.Font.Gotham
    description.TextSize = 12
    description.TextColor3 = Theme.Subtle
    description.BackgroundTransparency = 1
    description.TextXAlignment = Enum.TextXAlignment.Left

    local keybindButton = Instance.new("TextButton", container)
    keybindButton.Name = "KeybindButton"
    keybindButton.Size = UDim2.new(0, 120, 0, 28)
    keybindButton.Position = UDim2.new(1, -120, 0.5, -14)
    keybindButton.BackgroundColor3 = Theme.Bg2
    keybindButton.TextColor3 = Theme.Accent
    keybindButton.Font = Enum.Font.GothamSemibold
    keybindButton.TextSize = 14
    keybindButton.Text = Settings[settingKey].Name
    local kbCorner = Instance.new("UICorner", keybindButton)
    kbCorner.CornerRadius = UDim.new(0, 6)
    local kbStroke = Instance.new("UIStroke", keybindButton)
    kbStroke.Color = Theme.InputBorder
    kbStroke.Thickness = 1

    local listening = false
    keybindButton.MouseButton1Click:Connect(function()
        if listening then return end
        listening = true
        keybindButton.Text = "..."
        keybindButton.TextColor3 = Theme.Accent2
        
        local inputConn
        inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.Keyboard or input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.MouseButton2 or input.UserInputType == Enum.UserInputType.MouseButton3 then
                Settings[settingKey] = input.KeyCode
                keybindButton.Text = input.KeyCode.Name
                keybindButton.TextColor3 = Theme.Accent
                listening = false
                if inputConn then inputConn:Disconnect() end
                showNotify(labelText .. " set to " .. input.KeyCode.Name)
            elseif input.KeyCode == Enum.KeyCode.Escape then -- Cancel with Escape
                keybindButton.Text = Settings[settingKey].Name
                keybindButton.TextColor3 = Theme.Accent
                listening = false
                if inputConn then inputConn:Disconnect() end
            end
        end)
    end)
    container.Parent = nil
    return container
end

-- === CONFIG BAR ===
local configBar = Instance.new("Frame", frame)
configBar.Size = UDim2.new(1,0,0,40)
configBar.Position = UDim2.new(0,0,1,-40) -- At the bottom
configBar.BackgroundColor3 = Theme.Header
configBar.BackgroundTransparency = 0.3
configBar.ZIndex = 25

local configNameInput = Instance.new("TextBox", configBar)
configNameInput.Size = UDim2.new(0.5, -55, 0, 28)
configNameInput.Position = UDim2.new(0,10,0.5,-14)
configNameInput.Font = Enum.Font.Gotham
configNameInput.TextSize = 14
configNameInput.TextColor3 = Theme.Text
configNameInput.BackgroundColor3 = Theme.InputBackground
configNameInput.PlaceholderText = "Config Name"
configNameInput.Text = Settings.ConfigName
local cniCorner = Instance.new("UICorner", configNameInput)
cniCorner.CornerRadius = UDim.new(0,6)
local cniStroke = Instance.new("UIStroke", configNameInput)
cniStroke.Color = Theme.InputBorder
cniStroke.Thickness = 1

configNameInput.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        Settings.ConfigName = configNameInput.Text
        showNotify("Config name set to: " .. Settings.ConfigName)
    end
end)

local saveButton = Instance.new("TextButton", configBar)
saveButton.Size = UDim2.new(0.25, -10, 0, 28)
saveButton.Position = UDim2.new(0.5, -40, 0.5, -14)
saveButton.Text = "Save"
saveButton.Font = Enum.Font.GothamBold
saveButton.TextSize = 14
saveButton.TextColor3 = Theme.Frame
saveButton.BackgroundColor3 = Theme.Accent
local sbCorner = Instance.new("UICorner", saveButton)
sbCorner.CornerRadius = UDim.new(0,6)

local loadButton = Instance.new("TextButton", configBar)
loadButton.Size = UDim2.new(0.25, -15, 0, 28)
loadButton.Position = UDim2.new(0.75, -20, 0.5, -14)
loadButton.Text = "Load"
loadButton.Font = Enum.Font.GothamBold
loadButton.TextSize = 14
loadButton.TextColor3 = Theme.Frame
loadButton.BackgroundColor3 = Theme.Accent2
local lbCorner = Instance.new("UICorner", loadButton)
lbCorner.CornerRadius = UDim.new(0,6)

-- All UI Elements that need theme updates
local themableElements = {frame, header, title, notify, minimizeButton, themeSwitcher, resizeHandle, scrollFrame,
                          configBar, configNameInput, saveButton, loadButton, shadowStroke} 
                          -- Individual setting elements will be handled by re-applying theme function


-- === UI BUILD (Add elements to scrollFrame) ===
local allUIElements = {} -- Store all created UI components for easy access later

local function addElement(element)
    element.Parent = scrollFrame
    table.insert(allUIElements, element)
    table.insert(themableElements, element) -- Add to themable if it has standard parts
end

-- AIMLOCK SECTION
local aimlockSection = createSectionHeader("ðŸŽ¯ AIMLOCK", scrollFrame)
aimlockSection.LayoutOrder = 1; table.insert(allUIElements, aimlockSection); table.insert(themableElements, aimlockSection)
addElement(createSwitch("Aimlock Enabled", "AimlockEnabled", "Master toggle for aim assist."))
addElement(createKeybindInput("Aimlock Key", "AimlockKey", "Hold this key to activate aimlock."))
addElement(createModePicker("Aimlock Mode", "AimlockMode", {"Enemy", "Team", "Normal"}, "Filters targets by allegiance."))
addElement(createModePicker("Aimlock Part", "AimlockPart", {"Head", "Torso", "HumanoidRootPart"}, "Which body part to target."))
addElement(createSlider("Aimlock FOV", "AimlockFOV", 10, 500, 5, "Aim assist field of view radius (pixels)."))
addElement(createSlider("Aimlock Smoothness", "AimlockSmoothness", 1, 20, 1, "Aim movement smoothing. Higher is smoother."))
addElement(createSwitch("Aimlock Vis-Check", "AimlockVisibilityCheck", "Only aim at visible targets."))
-- addElement(createSwitch("Aimlock Prediction", "AimlockPrediction", "Predict target movement (basic)."))

-- ESP SECTION
local espSection = createSectionHeader("ðŸ‘ï¸ ESP", scrollFrame)
espSection.LayoutOrder = 2; table.insert(allUIElements, espSection); table.insert(themableElements, espSection)
addElement(createSwitch("ESP Enabled", "ESPEnabled", "Master toggle for all visual assistance."))
addElement(createSwitch("ESP Box", "ESPBox", "Draws a box around targets."))
addElement(createSwitch("ESP Name", "ESPName", "Displays target names."))
addElement(createSwitch("ESP Distance", "ESPDistance", "Shows distance to targets."))
addElement(createSwitch("ESP HealthBar", "ESPHealthBar", "Visualizes target health."))
addElement(createSwitch("ESP Line", "ESPLine", "Draws a line to targets."))
addElement(createSwitch("ESP Skeleton", "ESPSkeleton", "Draws target skeletons (performance heavy)."))
addElement(createSwitch("ESP Show Team", "ESPShowTeam", "Show ESP for teammates."))
addElement(createSwitch("ESP Show Enemies", "ESPShowEnemies", "Show ESP for enemies."))
addElement(createSlider("ESP Max Distance", "ESPMaxDistance", 50, 2000, 50, "Maximum range for ESP rendering."))

-- MISC SECTION
local miscSection = createSectionHeader("âš™ï¸ MISCELLANEOUS", scrollFrame)
miscSection.LayoutOrder = 3; table.insert(allUIElements, miscSection); table.insert(themableElements, miscSection)
addElement(createSwitch("Show FOV Circle", "ShowFOVCircle", "Visualizes the aimlock FOV on screen."))
addElement(createSwitch("Anti-Kick", "AntiKick", "Attempts to prevent server kicks."))


-- === MINIMIZE/EXPAND LOGIC ===
local minimized = false
local originalFrameHeight = frame.Size.Y.Offset
local headerHeight = header.Size.Y.Offset

minimizeButton.MouseButton1Click:Connect(function()
    minimized = not minimized
    minimizeButton.Text = minimized and "â–²" or "â–¼"
    
    local targetHeight = minimized and headerHeight or originalFrameHeight
    if not minimized then frame.Size = UDim2.new(frame.Size.X.Scale, frame.Size.X.Offset, 0, originalFrameHeight) end -- Reset height before animation if expanding

    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
    local frameTween = TweenService:Create(frame, tweenInfo, {Size = UDim2.new(frame.Size.X.Scale, frame.Size.X.Offset, 0, targetHeight)})
    frameTween:Play()

    scrollFrame.Visible = not minimized
    configBar.Visible = not minimized
    resizeHandle.Visible = not minimized
    notify.Visible = not minimized
    
    if not minimized then -- Store current height as original if user resized then minimized
        originalFrameHeight = frame.Size.Y.Offset
    end
end)


-- === THEME SWITCHER LOGIC ===
local currentThemeName = "Dark"
local function applyTheme(themeName)
    Theme = Themes[themeName]
    currentThemeName = themeName
    themeSwitcher.Text = themeName == "Dark" and "â˜¼" or "â˜¾" -- Sun for light, Moon for dark

    -- Update main elements
    frame.BackgroundColor3 = Theme.Frame
    header.BackgroundColor3 = Theme.Header
    title.TextColor3 = Theme.Accent
    notify.TextColor3 = Theme.Subtle
    minimizeButton.BackgroundColor3 = Theme.Bg2
    minimizeButton.TextColor3 = Theme.Text
    themeSwitcher.BackgroundColor3 = Theme.Bg2
    themeSwitcher.TextColor3 = Theme.Accent
    resizeHandle.ImageColor3 = Theme.Accent
    scrollFrame.ScrollBarImageColor3 = Theme.Accent
    shadowStroke.Color = themeName == "Dark" and Color3.fromRGB(0,0,0) : Color3.fromRGB(180,180,180) -- Lighter shadow for light theme
    
    -- Config Bar elements
    configBar.BackgroundColor3 = Theme.Header
    configNameInput.TextColor3 = Theme.Text
    configNameInput.BackgroundColor3 = Theme.InputBackground
    if configNameInput:FindFirstChildOfClass("UIStroke") then configNameInput:FindFirstChildOfClass("UIStroke").Color = Theme.InputBorder end
    saveButton.BackgroundColor3 = Theme.Accent
    saveButton.TextColor3 = Theme.Frame -- Assuming frame color is good contrast for accent
    loadButton.BackgroundColor3 = Theme.Accent2
    loadButton.TextColor3 = Theme.Frame

    -- Update all created UI components
    for _, uiElement in ipairs(allUIElements) do
        if uiElement:IsA("Frame") and uiElement.Parent == scrollFrame then -- It's a container for a setting
            local label = uiElement:FindFirstChildOfClass("TextLabel") -- Main label
            local descLabel
            for _, child in ipairs(uiElement:GetChildren()) do -- Find description label
                if child:IsA("TextLabel") and child.TextWrapped then descLabel = child end -- Simple check, could be more robust
            end

            if label then label.TextColor3 = Theme.Text end
            if descLabel then descLabel.TextColor3 = Theme.Subtle end
            
            -- Switch specific
            local switchFrame = uiElement:FindFirstChild("SwitchFrame")
            if switchFrame then
                local settingKey = string.gsub(uiElement.Name, "Container", "")
                switchFrame.BackgroundColor3 = Settings[settingKey] and Theme.Accent or Theme.SwitchOff
                local circle = switchFrame:FindFirstChild("SwitchCircle")
                if circle then circle.BackgroundColor3 = Settings[settingKey] and Color3.fromRGB(255,255,255) or Theme.SwitchCircleOff end
            end

            -- Mode Picker specific
            local ddButton = uiElement:FindFirstChild("DropdownButton")
            if ddButton then
                ddButton.BackgroundColor3 = Theme.Bg2
                ddButton.TextColor3 = Theme.Accent
                if ddButton:FindFirstChildOfClass("UIStroke") then ddButton:FindFirstChildOfClass("UIStroke").Color = Theme.InputBorder end
                local ddList = uiElement:FindFirstChild("DropdownList")
                if ddList then
                    ddList.BackgroundColor3 = Theme.Bg2
                    ddList.BorderColor3 = Theme.InputBorder
                    for _, optBtn in ipairs(ddList:GetChildren()) do
                        if optBtn:IsA("TextButton") then
                            optBtn.BackgroundColor3 = Theme.Bg2
                            optBtn.TextColor3 = Theme.Text
                        end
                    end
                end
            end
            
            -- Slider specific
            local sliderTrack = uiElement:FindFirstChild("SliderTrack")
            if sliderTrack then
                sliderTrack.BackgroundColor3 = Theme.SliderTrack
                local valLabel = uiElement:FindFirstChild("ValueLabel")
                if valLabel then valLabel.TextColor3 = Theme.Accent end
                local sliderProgress = sliderTrack:FindFirstChild("SliderProgress")
                if sliderProgress then sliderProgress.BackgroundColor3 = Theme.SliderProgress end
                local sliderThumb = sliderTrack:FindFirstChild("SliderThumb")
                if sliderThumb then sliderThumb.BackgroundColor3 = Theme.Accent2 end
            end

            -- Keybind specific
            local kbButton = uiElement:FindFirstChild("KeybindButton")
            if kbButton then
                kbButton.BackgroundColor3 = Theme.Bg2
                kbButton.TextColor3 = Theme.Accent
                 if kbButton:FindFirstChildOfClass("UIStroke") then kbButton:FindFirstChildOfClass("UIStroke").Color = Theme.InputBorder end
            end
            
        elseif uiElement:IsA("TextLabel") and uiElement.Parent == scrollFrame then -- Section Header
            uiElement.TextColor3 = Theme.Accent2
            local border = uiElement:FindFirstChildOfClass("Frame")
            if border then border.BackgroundColor3 = Theme.Accent2 end
        end
    end
    showNotify("Theme switched to: " .. themeName, 1.5)
end

themeSwitcher.MouseButton1Click:Connect(function()
    applyTheme(currentThemeName == "Dark" and "Light" or "Dark")
end)
applyTheme(currentThemeName) -- Apply initial theme

-- === ESP Drawing Functions ===
local function clearESP()
    for _, obj in pairs(espObjects) do
        if obj and obj.Parent then obj:Remove() end
    end
    espObjects = {}
end

local function drawESPSquare(position, size, color, thickness, targetParent)
    local es = Drawing.new("Square")
    es.Visible = true
    es.Position = position
    es.Size = size
    es.Color = color
    es.Thickness = thickness
    es.Transparency = 0.3
    es.Filled = false
    table.insert(espObjects, es)
end

local function drawESPLine(from, to, color, thickness)
    local el = Drawing.new("Line")
    el.Visible = true
    el.From = from
    el.To = to
    el.Color = color
    el.Thickness = thickness
    el.Transparency = 0.3
    table.insert(espObjects, el)
end

local function drawESPText(text, position, size, color, font, outline)
    font = font or Drawing.Fonts.Plex
    local et = Drawing.new("Text")
    et.Visible = true
    et.Text = text
    et.Position = position
    et.Size = size
    et.Color = color
    et.Center = true
    et.Outline = outline or true
    et.OutlineColor = Color3.new(0,0,0)
    et.Font = font
    et.Transparency = 0.1
    table.insert(espObjects, et)
end

local function drawESPHealthBar(position, size, health, maxHealth, targetParent)
    local barHeight = size.Y
    local barWidth = 5 -- Thickness of health bar
    
    -- Background
    local bgPos = Vector2.new(position.X - barWidth - 2, position.Y)
    local bg = Drawing.new("Quad") -- Use Quad for filled rectangle
    bg.PointA = bgPos
    bg.PointB = Vector2.new(bgPos.X + barWidth, bgPos.Y)
    bg.PointC = Vector2.new(bgPos.X + barWidth, bgPos.Y + barHeight)
    bg.PointD = Vector2.new(bgPos.X, bgPos.Y + barHeight)
    bg.Color = Color3.fromRGB(0,0,0)
    bg.Transparency = 0.4
    bg.Filled = true
    table.insert(espObjects, bg)

    -- Health fill
    local healthPercentage = math.clamp(health / maxHealth, 0, 1)
    local healthColor = Color3.fromHSV(0.33 * healthPercentage, 1, 1) -- Green to Red
    local fillHeight = barHeight * healthPercentage
    
    local fillPos = Vector2.new(bgPos.X, bgPos.Y + barHeight * (1 - healthPercentage))
    local fill = Drawing.new("Quad")
    fill.PointA = fillPos
    fill.PointB = Vector2.new(fillPos.X + barWidth, fillPos.Y)
    fill.PointC = Vector2.new(fillPos.X + barWidth, fillPos.Y + fillHeight)
    fill.PointD = Vector2.new(fillPos.X, fillPos.Y + fillHeight)
    fill.Color = healthColor
    fill.Transparency = 0.2
    fill.Filled = true
    table.insert(espObjects, fill)
end

local skeletonConnections = {
    {"Head", "UpperTorso"}, {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"}, {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"}, {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"}, {"RightUpperLeg", "RightLowerLeg"}, {"RightLowerLeg", "RightFoot"}
}
-- R15 Fallbacks if R6 parts are not found
local r15SkeletonMap = { Head="Head", UpperTorso="UpperTorso", LowerTorso="LowerTorso",
                         LeftUpperArm="LeftUpperArm", LeftLowerArm="LeftLowerArm", LeftHand="LeftHand",
                         RightUpperArm="RightUpperArm", RightLowerArm="RightLowerArm", RightHand="RightHand",
                         LeftUpperLeg="LeftUpperLeg", LeftLowerLeg="LeftLowerLeg", LeftFoot="LeftFoot",
                         RightUpperLeg="RightUpperLeg", RightLowerLeg="RightLowerLeg", RightFoot="RightFoot"}


local function drawESPSkeleton(character, color)
    local parts = {}
    for _, partName in pairs(r15SkeletonMap) do
        parts[partName] = character:FindFirstChild(partName)
    end
    -- Basic R6 check (HumanoidRootPart is usually a good indicator of a standard rig)
    if not parts.UpperTorso and character:FindFirstChild("Torso") then -- Likely R6
        parts.UpperTorso = character:FindFirstChild("Torso")
        parts.LowerTorso = character:FindFirstChild("HumanoidRootPart") -- Approximate
        -- R6 Limbs
        parts.LeftUpperArm = character:FindFirstChild("Left Arm")
        parts.RightUpperArm = character:FindFirstChild("Right Arm")
        parts.LeftUpperLeg = character:FindFirstChild("Left Leg")
        parts.RightUpperLeg = character:FindFirstChild("Right Leg")
        -- For R6, some connections might need adjustment or fewer drawn lines
        -- This skeleton drawer is primarily for R15 or rigs with R15-like naming
    end


    for _, connection in ipairs(skeletonConnections) do
        local p1Name, p2Name = connection[1], connection[2]
        local part1 = parts[p1Name]
        local part2 = parts[p2Name]

        if part1 and part2 then
            local pos1_2d, vis1 = Camera:WorldToViewportPoint(part1.Position)
            local pos2_2d, vis2 = Camera:WorldToViewportPoint(part2.Position)
            if vis1 and vis2 then
                drawESPLine(Vector2.new(pos1_2d.X, pos1_2d.Y), Vector2.new(pos2_2d.X, pos2_2d.Y), color, 1.5)
            end
        end
    end
end


-- === RENDER LOOP ===
local fovCircleDrawing = Drawing.new("Circle")
fovCircleDrawing.Visible = false
fovCircleDrawing.Radius = Settings.AimlockFOV
fovCircleDrawing.Color = Color3.fromRGB(255,255,255)
fovCircleDrawing.Thickness = 1
fovCircleDrawing.Filled = false
fovCircleDrawing.Transparency = 0.7
fovCircleDrawing.NumSides = 32 -- Smoother circle
table.insert(espObjects, fovCircleDrawing) -- Manage with other ESP objects

RunService.RenderStepped:Connect(function(dt)
    clearESP()
    
    -- Aimlock Logic
    aimlockActive = Settings.AimlockEnabled and UserInputService:IsKeyDown(Settings.AimlockKey)

    if aimlockActive then
        if not lockedTarget or not isValidTarget(lockedTarget) or (Settings.AimlockVisibilityCheck and not isVisible(getTargetPart(lockedTarget.Character))) then
            lockedTarget = getClosestTargetToCrosshair()
        end

        if lockedTarget and isValidTarget(lockedTarget) then
            local targetCharacter = lockedTarget.Character
            local targetPart = getTargetPart(targetCharacter)
            if targetPart then
                local aimPos = targetPart.Position
                -- Basic Prediction (if enabled)
                --[[ if Settings.AimlockPrediction and targetPart:IsA("BasePart") then
                    local vel = targetPart.AssemblyLinearVelocity
                    -- Crude prediction: aim slightly ahead based on velocity and a magic number for travel time
                    aimPos = aimPos + (vel * dt * 5) -- Adjust multiplier as needed
                end--]]

                local newCamCFrame = CFrame.new(Camera.CFrame.Position, aimPos)
                if Settings.AimlockSmoothness > 1 then
                    Camera.CFrame = Camera.CFrame:Lerp(newCamCFrame, dt * (25 / Settings.AimlockSmoothness))
                else
                    Camera.CFrame = newCamCFrame
                end
            end
        else
            lockedTarget = nil -- Ensure no stale target
        end
    else
        lockedTarget = nil -- Clear target if aim key not held or aimlock disabled
    end

    -- ESP Logic
    if Settings.ESPEnabled then
        local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end -- Can't calculate distance without local root

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                if not humanoid or humanoid.Health <= 0 then continue end

                local targetRoot = player.Character.HumanoidRootPart
                local distance = (targetRoot.Position - localRoot.Position).Magnitude
                if distance > Settings.ESPMaxDistance then continue end

                local isTeam = player.TeamColor == LocalPlayer.TeamColor
                if (isTeam and not Settings.ESPShowTeam) or (not isTeam and not Settings.ESPShowEnemies) then
                    continue
                end
                
                local head = player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("HumanoidRootPart") -- Fallback to root if no head
                if not head then continue end

                local screenPosHead, onScreenHead = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
                local screenPosRoot, onScreenRoot = Camera:WorldToViewportPoint(targetRoot.Position - Vector3.new(0, targetRoot.Size.Y/2, 0))
                
                if onScreenHead and onScreenRoot then
                    local modelVisible = Settings.AimlockVisibilityCheck and isVisible(head) -- Re-use vis check logic
                    local espColor
                    if isTeam then
                        espColor = Settings.ESPTeamColor
                    else
                        espColor = modelVisible and Settings.ESPVisibleColor or Settings.ESPOccludedColor
                    end

                    local boxHeight = math.abs(screenPosRoot.Y - screenPosHead.Y)
                    local boxWidth = boxHeight * 0.6 -- Aspect ratio for box

                    if Settings.ESPBox then
                        drawESPSquare(Vector2.new(screenPosHead.X - boxWidth/2, screenPosHead.Y), Vector2.new(boxWidth, boxHeight), espColor, 1.5, player.Character)
                    end
                    if Settings.ESPLine then
                        drawESPLine(Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y), Vector2.new(screenPosRoot.X, screenPosRoot.Y), espColor, 1)
                    end
                    
                    local textYOffset = -15
                    if Settings.ESPName then
                        drawESPText(player.DisplayName, Vector2.new(screenPosHead.X, screenPosHead.Y + textYOffset), 14, espColor)
                        textYOffset = textYOffset - 14
                    end
                    if Settings.ESPDistance then
                        drawESPText(string.format("%.0fm", distance), Vector2.new(screenPosHead.X, screenPosHead.Y + textYOffset), 13, espColor)
                    end
                    if Settings.ESPHealthBar then
                        drawESPHealthBar(Vector2.new(screenPosHead.X - boxWidth/2, screenPosHead.Y), Vector2.new(boxWidth, boxHeight), humanoid.Health, humanoid.MaxHealth, player.Character)
                    end
                    if Settings.ESPSkeleton then
                        drawESPSkeleton(player.Character, espColor)
                    end
                end
            end
        end
    end

    -- FOV Circle
    if Settings.ShowFOVCircle and Settings.AimlockEnabled then
        fovCircleDrawing.Visible = true
        fovCircleDrawing.Position = Vector2.new(Mouse.X, Mouse.Y) -- Center on mouse (typical crosshair)
        fovCircleDrawing.Radius = Settings.AimlockFOV
        fovCircleDrawing.Color = Theme.Accent -- Use theme accent for visibility
    else
        fovCircleDrawing.Visible = false
    end
end)


-- === CONFIGURATION SYSTEM ===
local CONFIG_FOLDER = "GNC_HUB_Configs"
if not isfolder(CONFIG_FOLDER) then makefolder(CONFIG_FOLDER) end

function SaveConfig(configName)
    local configData = {}
    for key, value in pairs(Settings) do
        if typeof(value) == "Color3" then
            configData[key] = {r=value.R, g=value.G, b=value.B}
        elseif typeof(value) == "EnumItem" then
            configData[key] = {enumType = value.EnumType.Name, name = value.Name}
        else
            configData[key] = value
        end
    end
    local success, err = pcall(function()
        writefile(CONFIG_FOLDER .. "/" .. configName .. ".json", HttpService:JSONEncode(configData))
    end)
    if success then
        showNotify("Config '"..configName.."' saved!", 2)
    else
        showNotify("Error saving config: "..tostring(err), 3)
    end
end

function LoadConfig(configName)
    local filePath = CONFIG_FOLDER .. "/" .. configName .. ".json"
    if not isfile(filePath) then
        showNotify("Config '"..configName.."' not found.", 2)
        return
    end
    
    local success, content = pcall(function() return readfile(filePath) end)
    if not success or not content then
        showNotify("Error reading config file: "..tostring(content), 3)
        return
    end

    local decodedSuccess, configData = pcall(HttpService.JSONDecode, HttpService, content)
    if not decodedSuccess or not configData then
        showNotify("Error parsing config data: "..tostring(configData), 3)
        return
    end

    for key, value in pairs(configData) do
        if Settings[key] ~= nil then -- Only load settings that exist in the current script's Settings table
            if type(value) == "table" and value.r ~= nil and value.g ~= nil and value.b ~= nil then -- Color3
                Settings[key] = Color3.fromRGB(value.r*255, value.g*255, value.b*255)
            elseif type(value) == "table" and value.enumType and value.name then -- EnumItem
                local enumType = Enum[value.enumType]
                if enumType and enumType[value.name] then
                    Settings[key] = enumType[value.name]
                end
            else
                Settings[key] = value
            end
        end
    end
    
    -- Update UI elements after loading settings
    currentConfig = configName
    configNameInput.Text = currentConfig
    applyTheme(currentThemeName) -- Re-apply theme to update all UI elements like sliders, switches based on new settings
    
    -- Manually update elements that applyTheme doesn't fully refresh regarding their values
    for _, element in ipairs(allUIElements) do
        if element:IsA("Frame") and element.Parent == scrollFrame then
            local settingKey = string.gsub(element.Name or "", "Container", "")
            if Settings[settingKey] ~= nil then
                 -- Slider update
                local valueLabel = element:FindFirstChild("ValueLabel")
                local track = element:FindFirstChild("SliderTrack")
                if valueLabel and track then
                    valueLabel.Text = tostring(Settings[settingKey])
                    local minVal, maxVal -- These would need to be stored or inferred
                    -- For now, assume slider creators registered these values or re-call createSlider logic
                    -- This part is tricky without storing min/max with the slider or re-parsing creation args
                    -- A quick fix is to just update the value label and hope the visual matches on next interaction
                    -- Or, when creating sliders, store their min/max/step in a dictionary accessible by settingKey
                end
                -- Keybind update
                local kbButton = element:FindFirstChild("KeybindButton")
                if kbButton and typeof(Settings[settingKey]) == "EnumItem" then
                     kbButton.Text = Settings[settingKey].Name
                end
                -- Mode Picker update
                local ddButton = element:FindFirstChild("DropdownButton")
                if ddButton then
                    ddButton.Text = Settings[settingKey]
                end
            end
        end
    end

    showNotify("Config '"..configName.."' loaded!", 2)
end

saveButton.MouseButton1Click:Connect(function()
    local nameToSave = configNameInput.Text
    if nameToSave == "" then nameToSave = "DefaultGNCConfig" end
    Settings.ConfigName = nameToSave -- Update internal setting
    SaveConfig(nameToSave)
end)

loadButton.MouseButton1Click:Connect(function()
    local nameToLoad = configNameInput.Text
    if nameToLoad == "" then nameToLoad = "DefaultGNCConfig" end
    LoadConfig(nameToLoad)
end)

-- Load default config on start if it exists
if isfile(CONFIG_FOLDER .. "/" .. Settings.ConfigName .. ".json") then
    LoadConfig(Settings.ConfigName)
else
    showNotify("Welcome to GNC Hub v2! Customize and save your config.", 3)
end

gui.Enabled = true -- Make sure GUI is enabled
showNotify("GNC Hub v2 Loaded. Enhanced by Assistant.", 2.5)